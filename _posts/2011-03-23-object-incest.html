---
layout: post
title: "Object Incest"
date: 2011-03-23
comments: false
categories:
 - engineering
 - anti-patterns
 - code
 - object oriented design
---

<div class='post'>
<i>Note: I thought I had read this term from somewhere else, but after a quick internet search turned up only dirty videos, I think I may be the sole "coiner" of the term.&nbsp;</i><br /><i><br /></i><br />Many inexperience developers (and experienced ones too) have been known to make several common mistakes in object oriented design. Hence, the coining of the terms <a href="http://en.wikipedia.org/wiki/Anti-pattern">anti-pattern</a> and <a href="http://www.codinghorror.com/blog/2006/05/code-smells.html">code smell</a> to refer to patterns of development (like design patterns) that lead to convoluted, overly complex code that costs exponentially to maintain and exhibits little value.<br /><br />Object incest is a pattern where two unrelated classes are intimately dependent on each other. Simply put, <i>if object A&nbsp;</i><i>directly&nbsp;</i><i>relies on object B and B relies directly on A</i>, you have two incestual objects. This usually happens to intermediate developers who realize that they need <a href="http://trese.cs.utwente.nl/taosad/separation_of_concerns.htm">separation of concerns</a>&nbsp;and break a class into two classes without actually breaking the dependencies. While it is understandable (and almost respectable) why a developer might commit object incest, it is no less dangerous and harmful to a code base full of child objects.<br /><br />Here is an example of object incest:<br /><br /><pre class="brush: csharp">class Brother {<br /> public Sister MySister { get; set; }<br /><br /> private void GetMyHairBrushed() {<br />  MySister.BrushHair(this);<br /> }<br /><br /> public void DefendFromBullies(Sister sis) {<br />  // ...<br /> }<br />}<br /><br />class Sister {<br /> public Brother MyBrother { get; set; }<br /><br /> public void BrushHair(Brother bro) {<br />  // ...<br /> }<br /><br /> private void GetRidOfBullies() {<br />  MyBrother.DefendFromBullies(this);<br /> }<br />}<br /></pre><br />This is wrong because the two objects are so involved that it's hard to tell them apart, breaking the principal of separation of concerns. You&nbsp;can fix this by extracting <i>roles</i>&nbsp;from the objects as&nbsp;interfaces. Therefore, each object depends on some kind of object that can fulfill a role. A brother object needs someone to brush his hair, a sister needs someone to defend her from bullies.<br /><br /><pre class="brush: csharp">class Brother : IDefenderOfTheWeak, IPersonWithHair {<br /> public IHairBrusher MyHairBrushPartner { get; set; }<br /> <br /> private void BrushMyHair() {<br />  MyHairBrushPartner.BrushHair(this);<br /> }<br /> <br /> public void DefendFromBullies(IWeakling weakling) {<br />  // ...<br /> }<br />}<br /><br />class Sister : IWeakling, IHairBrusher {<br /> public IDefenderOfTheWeak Defender { get; set; }<br /> <br /> public void BrushHair(IPersonWithHair hairyPerson) {<br />  // ...<br /> }<br /> <br /> private void FightOffBullies() {<br />  Defender.DefendFromBullies(this);<br /> }<br />}</pre><br />In the second example, the two objects are no longer reliant on each other. Now they only rely on the roles that each of them provide. Down the road it will be much easier to create other objects that implement those interfaces (roles) like Husband and Wife.</div>
