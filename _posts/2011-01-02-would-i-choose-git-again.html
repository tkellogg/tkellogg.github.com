---
layout: post
title: "Would I choose Git again?"
date: 2011-01-02
comments: false
categories:
 - git
 - engineering
---

<div class='post'>
I wrote <a href="http://newline/">a post</a> a few months ago about the reasons we chose to use Git over subversion and I think it's time to follow up that post and write about how its gone so far. We're an ASP.NET outfit, and as such there are a few considerations that might not apply to, say, the Linux kernel team. I'm going to break this up into three parts: my perspective, my team's perspective, and some tips for anyone who might want to also try using Git.<br /><br /><span class="Apple-style-span" style="font-size: large;">My Experiences With Git</span><br />I seriously love using Git. I make a branch for everything I do just like they recommend. An old-school member of our team made a comment, "we always considered branches as something to be avoided", hinting at SVN branches' trait of being hard to manage and keep in sync with the trunk. Git branches are very different from SVN branches - they are very light and easy to keep up to date.<br /><br />Git has some seriously awesome merging mechanisms. First, you can select from a list of merge algorithms (you really only need one of these, but hey, its great to have choices just in case). Then they also have rebase and cherry-picking. These last two aren't regular merges because their algorithms look at the history of the entire repository and make several [and possibly hundreds of] incremental merges. Because these schemes take history into account, you can actually do some serious refactoring and still apply patches to both the production and development branches with relatively little effort.<br /><br />Our team develops and maintains a web application that our company sells as a service. As such, we don't spend time on installers or maintaining previous versions because the only versions that matter are the version that's in production and the development version. Git allows us to cherry-pick hotfixes from development into production (or vice versa) without really thinking much. This would have been a small nightmare in SVN (and invoke suicidal tendencies in TFS). Back when we were using TFS there really wasn't any process or procedure that went into hotfixes. You basically just updated production. With Git, its incredibly easy to just stash whatever you're doing, checkout the production branch, fix a critical bug, test &amp; deploy it, an then cherry pick it back into the dev branch. Git works well for people who get interrupted by escalations (everyone??).<br /><br /><span class="Apple-style-span" style="font-size: large;">My Team's Experiences</span><br />My team hates Git. Well, that's a bit harsh and premature, but there was some backlash when we first switched. About three weeks in I gave a brown bag lunch presentation on Git to teach everyone how to use it. After that people generally caught on to the basics with exception of some merging snafus.<br /><br />Merging is actually an interesting point. TFS merging drove me nuts. Perhaps it was just the merge program, but I always felt like I had my hands tied. Now that we're using Git I feel free again to branch and merge at will, but one of my teammates seemed to be (at least at first) completely confused by Git merging. This was [probably] entirely due to the fact that Git Extensions didn't come with <a href="http://kdiff3.sourceforge.net/">kdiff </a>by default (they now offer a convenient all-in-one installer that includes kdiff &amp; Git).<br /><br />Another point of confusion in using Git GUIs was that <a href="http://code.google.com/p/tortoisegit/">TortoiseGit </a>makes it very difficult to see what's different between local and remote repositories. I think the Tortoise crew made too much of an effort to make it feel like TortoseSVN when in reality it left some very important questions unanswered (TortoiseSVN only has to answer 1 or 2 important questions, but Git GUIs need to answer 4 or 5 important questions). Among these unanswered questions are "what branch am I on?" and "have I pushed this to the server yet?". TortoiseGit doesn't provide a clear answer to either of these questions, so I had everyone make a switch to <a href="http://code.google.com/p/gitextensions/">Git Extensions</a>.<br /><br /><span class="Apple-style-span" style="font-size: large;">Tips for Future Git Users</span><br />We were forced to learn a few lessons pretty quickly. I'll list them here in paragraph format...<br /><br /><a href="http://en.wikipedia.org/wiki/Graphical_user_interface">GUIs </a>are still young. Most Git users are sick Linux users who live by vi &amp; grep, so developing a decent GUI hasn't really been a priority for Git (there is an official Git GUI that ships with Git, but it possesses some serious <a href="http://www.urbandictionary.com/define.php?term=suckage">suckage</a>). If you work in a Microsoft/Windows outfit there is no conceivable way your coworkers will be happy with command line, so a good GUI is critical. <b>Use <a href="http://code.google.com/p/gitextensions/">Git Extensions</a>!</b><br /><b><br /></b><br />Setting up a central server is not entirely straightforward. While SVN is distributed as either a client or a server, Git has no reason to require a central server so this was also an afterthought. <b>Use <a href="https://github.com/sitaramc/gitolite#start">gitolite</a> on Linux</b>. Use the package manager method of installing it, its very easy to get it started and its also easy to maintain.<br /><br />SSH keys are problematic. Try to use putty/plink to manage keys if possible. OpenSSH is very un-Windows-like.<br /><br />Unit tests are good and they can make Git shine even brighter. If you maintain a generally complete unit test suite you can have Git utilize your test runner to quickly find where code started breaking. The "bisect" command can take a program or command that returns 0 or 1 (standard success/failure codes, so throwing exceptions would work) and perform a binary search through past commits to find the first place where a test started failing. This could also work great if you're a scripting guru - write a short script to check for some text (like "CREATE TABLE X") in a particular file and Git will do the leg work.<br /><br /><span class="Apple-style-span" style="font-size: large;">Conclusive Thoughts</span><br />Git is very powerful and can adapt to any workflow. If process is important to you, Git will enable you in whatever process you choose. If process isn't important, Git won't get in your way. It is very scalable via its distributed nature (ref <a href="http://whygitisbetterthanx.com/#any-workflow">dictator and lieutenants</a>). It's also great for small personal projects that I do in my spare time. I can still have code version controlled without sharing it with anyone, but when I want to I can push it to <a href="https://github.com/">Github</a> (another awesome idea). However, if your coworkers are generally stagnant and opposed to change, Git will drive them nuts and you will hate your life. <i>Choose Git only if you want a program that will abstract away mundane tasks like merging but you don't mind having to change your world view towards version control.</i></div>
