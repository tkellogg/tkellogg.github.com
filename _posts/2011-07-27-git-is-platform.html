---
layout: post
title: "Git is a platform"
date: 2011-07-27
comments: false
categories:
 - git
 - dvcs
 - engineering
---

<div class='post'>
This evening I stuck my head in at <a href="http://quickleft.com/">quickleft's</a> <a href="http://quickleft.com/blog/tag/hackfest">hackfest</a> downtown boulder. They gave a great intro to ruby &amp; sinatra. Sinatra is mind-bendingly simple. It makes you wonder why you've been doing anything but sinatra.<div><br /></div><div>Anyway, while I was playing around at the hackfest they introduced heroku, which is a cloud platform for ruby. Heroku uses git to let you manage your application's files on the server. Pushing a brand new repo creates a new domain name and sets up the infrastructure for your app. They built a very cool application on top of the <i>git platform</i>.</div><div><br /></div><div>Github has been doing this for a while. I blogged earlier about <a href="http://timkellogg.blogspot.com/2011/02/internal-secrets-of-git.html">github</a> and the things they've done with git. The most public things include git as a blogging/wiki engine as well as a static website generator (github pages). You can also fork <a href="https://github.com/icefox/git-achievements">git-achievements</a> and broadcast your mastery over git, <a href="http://tkellogg.github.com/git-achievements/">like I did</a>. Honestly, the things you can do with git are endless since it is, after all, nothing more than a versioning filesystem in user space.</div><div><br /></div><div>I think this is the biggest thing that separates git from other version control systems. No one has done anything with SVN beyond simple pre or post-commit hook scripts. TFS has a lot of application infrastructure built <i>around</i>&nbsp;it, but it doesn't build <i>on top</i>&nbsp;of it's version control system. Neither does mecurial or bazaar, even though they are also distributed version control systems.&nbsp;</div><div><br /></div><div>The git folks really focused on defining git as a standard rather than an application. By that I'm referring to how they defined objects, trees, packfiles, etc (see <a href="http://progit.org/book/ch9-0.html">progit</a>) instead of focusing on developing an application. For much of it's lifetime git was nothing but a hodgepodge of shell scripts and C libraries. Now days there are <a href="https://github.com/igorgue/git-sharp/wiki">several</a> <a href="http://www.jgit.org/">varying</a> <a href="http://libgit2.github.com/">implementations</a> <a href="http://deadpuck.net/blag/serving-git/">of</a> <a href="http://git-scm.com/">git</a>. The fact that git is so widely programatically accessible is making it insanely easy to leverage inside programs. I'm still waiting for a .NET app to do something big with git#...or maybe I could.</div></div>
