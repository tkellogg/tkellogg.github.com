---
layout: post
title: "Unit testing databases - with NHibernate!"
date: 2011-03-17
comments: false
categories:
 - databases
 - unit testing
 - code
 - csharp
---

<div class='post'>
One of the pesky problems with databases is unit testing the database portion of your application. For instance, it's enough of a pain to tear down and restore data to it's original state, but it's even harder if your application code requires you to commit changes. A while ago I saw&nbsp;<a href="http://stackoverflow.com/questions/321180/how-do-i-test-database-related-code-with-nunit">this stack overflow question</a> that said you could wrap all your code in a TransactionScope like:<br /><br /><pre class="brush: csharp">using (new TransactionScope())<br />{<br />    // Database access code here<br />}<br /></pre><br />When .Dispose() is called at the end of the using block, the code is supposed to roll back all transactions, even if they were committed. After reading <a href="http://msdn.microsoft.com/en-us/library/system.transactions.transactionscope.aspx">the documentation</a> I realized that any new transactions will use this transaction scope, and hence be rolled back when the transaction scope rolls back at the end of the using block.<br /><br />This all seems like a great idea for ADO.NET code, but I was skeptical of using this with NHibernate because I know NHibernate does funny things with the session and how it creates transactions. Even though I've known about this trick for some time, I never trusted it or even took the time to actually test it...until now.<br /><br />I tested this idea out inside the scope of our application code which I'm basically just pasting here. So bear with some of the abstraction code we have built up in IGenericDAO and Container.<br /><br /><pre class="brush: csharp">[Test]<br />public void CheckNHibernateMappings()<br />{<br />    using (new TransactionScope())<br />    {<br />        // IGenericDAO is our abstraction layer for accessing NHibernate<br />        var dao = Container.Resolve&lt;IGenericDAO&lt;WorkflowTransition&gt;&gt;();<br />        var obj = new WorkflowTransition() { FromFk = 1, ToFk = 2, IsAllowed = true, WorkflowFk = 1, RightFk = 1 };<br />        dao.Save(obj);<br />        dao.CommitChanges();<br /><br />        var selected = dao.SelectById(obj.WorkflowTransitionId);<br />        Assert.That(selected.WorkflowTransitionId, Is.GreaterThan(0));<br />        Assert.That(selected.To, Is.EqualTo(2));<br />    }<br />}<br /></pre><br />I placed a breakpoint at line 12, after CommitChanges(). I debugged the unit test and when it stopped at the breakpoint I ran this query in SSMS:<br /><br /><pre class="brush: sql">select * from WorkflowTransitions with (nolock)<br /></pre><br />The query returned the row I just inserted. The <i>nolock</i>&nbsp;table hint means to&nbsp;ignore any locks that might be on the table and read everything, even uncommitted data. This means we can see the results of NHibernate's &nbsp;<i>insert</i>&nbsp;statement without having to mess with the SQL profiler. If you run the query without the nolock option it hangs until timeout. I then let the test finish and ran the query again. This time the row was gone!<br /><br />Apparently, this TransactionScope is fully capable of rolling back all transactions, even if they were created automagically by NHibernate. I presume this means it will work with any ORM framework, not just NHibernate.</div>
