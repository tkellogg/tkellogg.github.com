---
layout: post
title: "C# Reflection Performance And Ruby"
date: 2012-02-10
comments: false
categories:
 - ruby
 - performance
 - engineering
 - code
 - csharp
---

<div class='post'>
I've always known that reflection method invocations C# are slower than regular invocations, but I've never never known to what extent. So I set out to make an experiment to demonstrate the performance of several ways to invoke a method. Frameworks like <a href="http://nhforge.org/" target="_blank">NHibernate</a> or the <a href="http://www.mongodb.org/display/DOCS/CSharp+Language+Center" target="_blank">mongoDB driver</a> &nbsp;are known to serialize and deserialize objects. In order to do either of these activities they have to scan the properties of an object and dynamically invoke them to get or set the values. Normally this is done via reflection. However, I want to know if the possibility of <a href="http://en.wikipedia.org/wiki/Memoization" target="_blank">memoizing</a> a method call as an expression tree or delegate could offer significant performance benefits. On the side, I also want to see how C# reflection compares to Ruby method invocations.<br /><br />I posted the full source to&nbsp;<a href="https://github.com/tkellogg/ReflectionPropertyInvokeBenchmark">a public github repo</a>. To quickly summarize, I wrote code that sets a property on an object 100 million times in a loop. Any setup (like finding a <span style="font-family: 'Courier New', Courier, monospace;">PropertyInfo</span> or <span style="font-family: 'Courier New', Courier, monospace;">MethodInfo</span>) is not included in the timings. I also checked the generated IL to make sure the compiler wasn't optimizing the loops. Please browse the code there if you need the gritty details.<br /><br />Before I get into the implementation details, here are the results:<br /><br /><iframe frameborder="no" height="300px" scrolling="no" src="http://www.google.com/fusiontables/embedviz?&amp;containerId=gviz_canvas&amp;q=select+col0%2C+col1+from+2840399+&amp;qrs=where+col0+%3E%3D+&amp;qre=+and+col0+%3C%3D+&amp;qe=+limit+6&amp;viz=GVIZ&amp;t=BAR&amp;width=500&amp;height=300" width="500px"></iframe><br /><br />You can see that a reflection invoke is on the order of a hundred times slower than a normal property (set) invocation.<br /><br />Here's the same chart but without the reflection invocation. It does a better job of showing the scale between the other tests.<br /><br /><iframe frameborder="no" height="300px" scrolling="no" src="http://www.google.com/fusiontables/embedviz?&amp;containerId=gviz_canvas&amp;q=select+col0%2C+col1+from+2840399+where+col1+%3C+'25000'&amp;qrs=+and+col0+%3E%3D+&amp;qre=+and+col0+%3C%3D+&amp;qe=+limit+5&amp;viz=GVIZ&amp;t=BAR&amp;width=500&amp;height=300" width="500px"></iframe><br /><br />Obviously, the lesson here is to directly invoke methods and properties when possible. However, there are times when you don't know what a type looks like at compile time. Again, object serialization/deserialization would be one of those use cases.<br /><br />Here's an explanation of each of the tests:<br /><br /><span style="font-size: large;">Reflection Invoke</span>&nbsp;(<a href="https://github.com/tkellogg/ReflectionPropertyInvokeBenchmark/blob/363b1242a0210c9d7deb4db2571134333476e96b/ReflectionBenchmark/Program.cs#L59" target="_blank">link</a>)<br /><br />This is essentially&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">methodInfo.Invoke(obj, new[]{ value }</span>&nbsp;on the setter method of the property. It is by far the slowest approach to the problem. It's also the most common way to solve the problem of insufficient pre-compile time&nbsp;knowledge.<br /><br /><span style="font-size: large;">Direct Invoke</span>&nbsp;(<a href="https://github.com/tkellogg/ReflectionPropertyInvokeBenchmark/blob/363b1242a0210c9d7deb4db2571134333476e96b/ReflectionBenchmark/Program.cs#L47" target="_blank">link</a>)<br /><br />This is nothing other than <span style="font-family: 'Courier New', Courier, monospace;">obj.Property = value</span>. Its as fast as it gets, but impractical for use cases where you don't have pre-compile time&nbsp;knowledge of the type.<br /><br /><span style="font-size: large;">Closure</span>&nbsp;(<a href="https://github.com/tkellogg/ReflectionPropertyInvokeBenchmark/blob/363b1242a0210c9d7deb4db2571134333476e96b/ReflectionBenchmark/Program.cs#L92" target="_blank">link</a>)<br /><br />This isn't much more flexible than a direct invoke, but I thought it would be interesting to see how the performance degraded. This is where you create a function/closure (&nbsp;<span style="font-family: 'Courier New', Courier, monospace;"><exampletype, string="">(x,y) =&gt; x.Property = y</exampletype,></span>) prior to the loop and just invoke the function inside the loop (<span style="font-family: 'Courier New', Courier, monospace;">action(obj, value)</span>). At first sight it appears to be half as fast as a direct invoke, but there are actually two method calls involved here, so it's actually not any slower than a direct invoke.<br /><br /><span style="font-size: large;">Dynamic Dispatch</span>&nbsp;(<a href="https://github.com/tkellogg/ReflectionPropertyInvokeBenchmark/blob/363b1242a0210c9d7deb4db2571134333476e96b/ReflectionBenchmark/Program.cs#L78" target="_blank">link</a>)<br /><br />This uses the C# 4.0 dynamic feature directly. To do this, I declared the variable as dynamic&nbsp;and assigned it using the same syntax as a direct invoke. Interestingly, this performs only 6x slower than direct invoke and about 20x faster than reflection invoke. Take note, if you need reflection, use dynamic as often as possible since it can really speed up method invocation.<br /><br /><span style="font-size: large;">Expression Tree</span>&nbsp;(<a href="https://github.com/tkellogg/ReflectionPropertyInvokeBenchmark/blob/363b1242a0210c9d7deb4db2571134333476e96b/ReflectionBenchmark/Program.cs#L110" target="_blank">link</a>)<br /><br />The shortcoming of most of the previous approaches is that they require pre-compile time&nbsp;knowledge of the type. This time I tried building an expression tree (a C# 3.0 feature) and compiled a delegate that invokes the setter. This makes it flexible enough that you can call any property of an object without compile-time knowledge of the name, as long as you know the return type. In this example, like the closure, we're indirectly setting the property, so two method calls. With this in mind, it took almost 2.5 times as long as the closure example, even though they should be functionally equivalent operations. It must be that expression trees compiled to delegates aren't actually as simple as they appear.<br /><br /><span style="font-size: large;">Expression Tree with Dynamic Dispatch</span> (<a href="https://github.com/tkellogg/ReflectionPropertyInvokeBenchmark/blob/363b1242a0210c9d7deb4db2571134333476e96b/ReflectionBenchmark/Program.cs#L141" target="_blank">link</a>)<br /><br />Since the expression tree approach requires compile-time knowledge of the return type, it isn't as flexible. Ideally you could use C# 4.0's covariance feature and cast it to <span style="font-family: 'Courier New', Courier, monospace;">Action<object, object=""><object, object=""></object,></object,></span>&nbsp;which compiles, but fails at runtime. So for this one, I just assigned the closure to a variable typed as&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">dynamic</span>&nbsp;to get around the compile/runtime casting issues.<br /><br />As expected, it's the slowest approach. However, its still 16 times faster than direct reflection. Perhaps, memoizing method calls, like property sets and gets, like this would actually yield a significant performance improvement.<br /><br /><span style="font-size: x-large;">Compared To Ruby</span><br /><br />I thought I'd compare these results to Ruby where all method calls are dynamic. In Ruby, a method call looks first in the object's immediate class and then climbs the ladder of parent classes until it finds a suitable method to invoke. Because of this behavior I thought I would be interesting to also try a worst-case scenario with a deep level of inheritance.<br /><br />To do this fairly, I initially wrote a <span style="font-family: 'Courier New', Courier, monospace;">while</span> loop in Ruby that counted to 100 million. I rewrote the while loop in <span style="font-family: 'Courier New', Courier, monospace;">n.each</span> syntax and saw the execution time get cut in half. Since I'm really just trying to measure method invocation time, I stuck with the <span style="font-family: 'Courier New', Courier, monospace;">n.each</span> syntax.<br /><br /><iframe frameborder="no" height="300px" scrolling="no" src="https://www.google.com/fusiontables/embedviz?&amp;containerId=gviz_canvas&amp;q=select+col0%2C+col1+from+2846447+&amp;qrs=where+col0+%3E%3D+&amp;qre=+and+col0+%3C%3D+&amp;qe=+limit+4&amp;viz=GVIZ&amp;t=BAR&amp;width=500&amp;height=300" width="500px"></iframe><br /><br />I honestly thought C# Reflection would be significantly faster than the Ruby with 5 layers of in inheritance. While C# already holds a reference to the method (<span style="font-family: 'Courier New', Courier, monospace;">MethodInfo</span>), Ruby has to search up the ladder for the method each time. I suppose Ruby's performance could be due to the fact that it's written in C and specializes in dynamic method invocation.<br /><br />Also, it interests me why C# dynamic is so much faster than Ruby or reflection. I took a look at the IL code where the dynamic invoke was happening and was surprised to find a <span style="font-family: 'Courier New', Courier, monospace;">callvirt</span> instruction. I guess I was expecting some sort of specialized <span style="font-family: 'Courier New', Courier, monospace;">calldynamic</span> instruction (<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/" target="_blank">Java 7 has one</a>). The answer is actually a little more complicated. There seems to be several calls - most are&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">call</span> instructions to set the stage (<span style="font-family: 'Courier New', Courier, monospace;">CSharpArgumentInfo.Create</span>) and one&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">callvirt</span> instruction to actually invoke the method.<br /><br /><span style="font-size: x-large;">Conclusion</span><br /><br />Since the trend of C# is going towards using more <a href="http://msdn.microsoft.com/en-us/library/bb397947.aspx" target="_blank">Linq</a>, I find it interesting how much of a performance hit developers are willing to exchange for more readable and compact code. In the grand scheme of things, the performance of even a slow reflection invoke is probably insignificant compared to other bottlenecks like database, HTTP, filesystem, etc.<br /><br />It seems that I've proved the point that I set out to prove. There is quite a bit of performance to be gained by memoizing method calls into expression trees. The application would obviously be best in JSON serialization, ORM, or anywhere when you have to get/set lots of properties on an object with no compile-time knowledge of the type. Very few people, if any, are doing this - probably because of the added complexity. The next step will be to (hopefully) build a working prototype.<br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Tim Kellogg</div>
<div class='content'>
Jordan - I&#39;ve looked at iSynapticCommons before and I&#39;ve been very impressed with what I&#39;ve seen. I see you&#39;re emitting CLR OpCodes to build code. An alternative approach is to use Mono.CSharp.Evaluator to compile significant amounts of code at runtime (http://tirania.org/blog/archive/2008/Sep-10.html)</div>
</div>
<div class='comment'>
<div class='author'>Jordan Terrell</div>
<div class='content'>
You should checkout out DynamicMethod creation.  I used it to implement my Clonable class for extremely fast object cloning.  You can find the code for that here: https://github.com/iSynaptic/iSynaptic.Commons/blob/master/Application/iSynaptic.Commons/Runtime/Serialization/Cloneable.cs<br /><br />I wrote a little bit about this here: http://blog.jordanterrell.com/post/iSynapticCommons-Cloneablelt;Tgt;.aspx</div>
</div>
<div class='comment'>
<div class='author'>Tim Kellogg</div>
<div class='content'>
Thanks Peter!</div>
</div>
<div class='comment'>
<div class='author'>Peter Weissbrod</div>
<div class='content'>
Same with NHibernate. Bytecode is being dynamically generated for data mappings upon startup, which results in a slow up-front load when creating a session factory, but usually you create one session factory per app domain.<br /><br />I dont know what they do with ORMs in Ruby (I wish I did) but in .NET all popular ORMs cache data mappings in some format OR they use dynamic expando objects.<br /><br />These are some great figure you have put together!</div>
</div>
<div class='comment'>
<div class='author'>Tim Kellogg</div>
<div class='content'>
That&#39;s good to know. I didn&#39;t get a chance to browse the source. I have a feeling many libraries don&#39;t take advantage of reflection caching.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
The C# mongodb driver does indeed cache it&#39;s reflection by compiled expression trees at runtime.</div>
</div>
</div>
