---
layout: post
title: "Semantic versioning"
date: 2011-07-10
comments: false
categories:
 - engineering
 - language
---

<div class='post'>
I've seen some interesting software version sequences. Like Windows 3, 3.1, 3.11, 95, 95, ME, XP, Vista, 7. Or Oracle DBMS v5, v6, 7, 8, 8i, 9i, 10g , 11g&nbsp;(what does the&nbsp;<i>g</i>&nbsp;mean??). I've seen all sorts of version schemes to designate major versions, minor versions, patches, and other types of releases. (The worst ones are always when marketing gets involved).<br /><br /><a href="https://github.com/mojombo">Tom Preston-Werner</a> formalized the major-minor-point release (<i>X.X.X</i>)&nbsp;scheme at <a href="http://semver.org/">semver.org</a>. I highly recommend anyone who considers&nbsp;themselves&nbsp;a professional developer to read every word in the article at <a href="http://semver.org/">semver.org</a>. The beauty of semantic versioning is that there isn't anything new or innovative about it at all. It's all what you already know to be true. All versions &lt;1.0.0 are development versions. Once 1.0 hits, the public interface is solidified. If and only if you break backwards compatibility you have to increase the major version. Minor versions and point releases (1.X.0 and 1.0.X) are for various levels of new features and bug fixes.<br /><br />When you release software labeled with semantic versions you make it easy for people to quickly asses how significant the release is (I might skip a point release and upgrade to minor releases, but I might avoid a major release due to the&nbsp;incompatibilities&nbsp;it might cause). It also forces the developers to exercise restraint in breaking compatibility with previous releases.<br /><br />The trouble with semantic versions in the corporate world is that marketing always has&nbsp;ulterior&nbsp;motives. They want to release a major version to make the product feel alive; they want to downplay breaking changes to a minor version to keep customers; or they want to introduce new terms that mean nothing to the average user (XP for <i>eXPerience, </i>Vista because it sounds cool). Those names are great for development code-names but they detract from a buyer's experience (I use the term buyer loosely to mean any potential user) in determining compatibility between products.<br /><br />In .NET assemblies, there are four segments supported with the AssemblyVersion and AssemblyFileVersion attributes (major, minor, build number, revision). This seems fine until you want to release alphas, betas and release candidates. The semantic version for a 1.0 beta release would be 1.0.0beta1 indicating that this is the first beta for the 1.0.0 release (you can use any string of alphabetical characters, not just <i>beta</i>). In a .NET assembly <a href="http://stackoverflow.com/questions/64602/what-are-differences-between-assemblyversion-assemblyfileversion-and-assemblyinf">you do this as follows</a>:<br /><br /><pre class="brush: csharp">[assembly: AssemblyVersion("1.0.0")]<br />[assembly: AssemblyFileVersion("1.0.0.253")]<br />[assembly: AssemblyInformationalVersion("1.0.0beta1")]<br /></pre><br />The new attribute here is obviously <a href="http://msdn.microsoft.com/en-us/library/system.reflection.assemblyinformationalversionattribute.aspx">AssemblyInformationalVersion</a>, which is used to specify more arbitrary strings. It will show up in the Windows properties dialog as the assembly version (otherwise <a href="http://msdn.microsoft.com/en-us/library/system.reflection.assemblyversionattribute(v=vs.71).aspx">AssemblyVersion </a>will be used). Also, the <a href="http://msdn.microsoft.com/en-us/library/system.reflection.assemblyfileversionattribute.aspx">AssemblyFileVersion </a>is used to indicate build numbers. So while working on the 1.0.0 release, we also have a continuous integration environment like <a href="http://www.jetbrains.com/teamcity/">Teamcity </a>or <a href="http://hudson-ci.org/">Hudson </a>building the code each night and incrementing the build version. However, continuous integration environments shouldn't need to have any impact on what you actually tag the version as.<br /><br />As Tom says in the article, kinda sorta following the standard doesn't reap much benefit. But once we all start releasing software that conforms <i>exactly</i> to this standard, then users can more efficiently understand which two components are compatible and which aren't. I believe this applies to all software, not just software that supplies a public API.</div>
