---
layout: post
title: "Why I hate generated code"
date: 2011-12-26
comments: false
categories:
 - open source
 - generated code
 - engineering
 - code
 - csharp
---

<div class='post'>
If you've worked with me for any amount of time you'll soon figure out that I often profess that <i>"I hate generated code"</i>. This position comes from years of experience with badly generated code.&nbsp;Let me explain.<br /><br /><h2>The baby comes with a lot of bathwater</h2>In the past year I had an experience with a generated data layer where <a href="http://www.codesmithtools.com/">CodeSmith</a> was used to generate a table, 5 stored procedures, an entity class, a data source class, and a factory class for each entity that was generated. My task was to convert this code into <a href="http://nhforge.org/">NHibernate</a> mappings.<br /><br />The interesting thing about this work is how little of the generated code was actually being used. I'm sure, in the beginning, the developer's thoughts were along the lines<i> "oh look at all this code I don't have to write manually :D"</i>. However, after some time, subsequent developer's thoughts were along the lines of <i>"with all this dead code, it's hard to find real problems"</i>.&nbsp;It's funny how some exciting breakthroughs turn into headaches down the road.&nbsp;The table is always used, but some entities are created &amp; read but never modified, others are only created during migrations and only read from during run time.<br /><br />Code generators often produce code you don't need. Since all code requires maintenance, dead code is just a liability because it doesn't provide any benefit. I always delete dead code and commented out code (it'll live on in version control, no need to release it into production).<br /><br />There are several professional developer communities that generate code as a way of life. <a href="http://guides.rubyonrails.org/command_line.html">Ruby on Rails</a> comes prepackaged with scripts to generate models, views, and controllers in a single command. <a href="http://www.asp.net/mvc/tutorials/older-versions/controllers-and-routing/creating-a-controller-cs">ASP.NET MVC</a> will generate controllers and views with a couple clicks. And if you've ever used either of these frameworks, you'll probably find yourself deleting a lot of generated code.<br /><br /><h2>The problem of transient code generation</h2>The issue that I keep running into with my policy of hating code generation is that it's nearly impossible to be a professional software engineer and not generate code. The most fundamental problem is compilers. When you run a compiler over your source code, it <i>generates</i>&nbsp;some sort of machine readable code that is optimized for various goals like speed or debugging or different platform targets.<br /><br />While I hate code generators, it's hard to argue how I could possibly hate compilers. They allow me to write code once and compile it several different ways and achieve different goals. Therefore, I have to introduce my first caveat - I don't hate all generated code, <i>I only hate generated source code</i>.<br /><br />This problem of hating generated code is complicated further by the fact that NHibernate generates source code too. You don't ever check in the code that NHibernate generates because it's done at run time. The most obvious way NHibernate generates code is the SQL that is written in the background to query &amp; perform DML operations. (For those questioning if SQL is source code, consider how SQL is compiled into an execution plan prior to execution). It's also hard to argue that I hate this kind of code generation because it doesn't suffer from the same problems of the CodeSmith generated code. It only generates code <i>just-in-time</i>&nbsp;meaning that it's only generated when needed, so there isn't any extra code generated.<br /><br />Since NHibernate and compilers do code generation in a way that I like, I'm going to refine my statement to <i>"I hate generated persistent code"</i>. This generally means, I still hate generated code when the resulting code sticks around long enough for a fellow developer to have to deal with it.<br /><br /><h2>The thin line between good and bad code generation</h2>When is generated code persistent and when is it transient? We already decided that code generation isn't so bad when it happens during of after the compilation process. But my statement is that I hate persistent code. There are other cases of code generators generating transient source code. One such example is in <a href="https://github.com/iSynaptic/iSynaptic.Commons">iSynaptic.Commons</a>.<br /><br />Since C# doesn't yet (and probably won't ever) include <a href="http://insanecoding.blogspot.com/2010/03/c-201x-variadic-templates.html">variadic templates</a> or variadic generic types, writers of .NET API's often write some really redundant code to account for all combinations of generic methods or types. I know I've done it. This example uses <a href="https://github.com/iSynaptic/iSynaptic.Commons/blob/master/Application/iSynaptic.Commons/FuncExtensions.tt">a T4 template</a> to produce a C# file with a <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">*.generated.cs</span> extension. The T4 template is <a href="https://github.com/iSynaptic/iSynaptic.Commons/blob/master/Application/iSynaptic.Commons/iSynaptic.Commons.csproj#L195">executed on build</a>&nbsp;but not ignored from version control.<br /><br />I do like this approach because it takes a DRY approach to a redundant problem without much complication. Another thing I really like about this approach is that <a href="http://msdn.microsoft.com/en-us/library/bb126445.aspx">T4 templates</a> are a standard part of Visual Studio and are <a href="http://tirania.org/blog/archive/2009/Mar-10.html">executable from Mono</a> as well. As such, they can be considered a free tool that is openly available (important for open source projects) and, more importantly, are executed as part of the build process.<br /><br />Another thing I like about this approach is the usage of partial classes to separate the generated portion of the class from the non-generated portion. This minimizes the amount of code that is sheltered from refactoring tools (code inside the *.tt file).<br /><br />The thing I hate about this particular&nbsp;iSynaptic.Commons&nbsp;example is that the generated file is included in version control. I think, perhaps, this is reduced to a small pet peeve of mine since the generated code isn't wasteful and is updated on every build. Still, I would like a mechanism to (a) have the file ignored from the IDE's perspective and (b) ignored from version control. I wouldn't want anyone to mistakenly edit the file when they should be editing the T4 template.<br /><br /><h2>Summary</h2>The end result of my thought is <i>"I hate source code that is generated prior to the build process"</i>. I want to further say that I also hate generated code that is checked into version control, but this is a bit of a lesser point. However, code generation can be a useful tool; as seen in the cases of NHibernate and T4 templates. But even still, code generation should be used wisely and with care. Generating excess code can become a liability that detracts from the overall value of a product.</div>
