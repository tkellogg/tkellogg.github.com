---
layout: post
title: "Declaring the Future of Programming"
date: 2011-01-09
comments: false
categories:
 - declarative
 - engineering
 - philosophy
 - code
---

<div class='post'>
Programming languages have developed significantly over the past several decades. I hypothesize that this development has tended more towards declarative syntax than imperative. The future of programming languages will only become more declarative in the years to come.<br /><br />In the beginning was machine code. Programmers wrote programs by stringing together arcane byte codes of instructions and parameters. Programs were getting pretty hard to read so they made assemblers so you could write instructions in plain text, complete with comments. An assembler program would process the source code and turn each instruction into it's equivalent machine code. This is imperative programming at its most pure state.<br /><br />When the first C compiler was written it immediately became popular because the programmer only had to declare what should happen in the program and the compiler would generate the necessary machine code to make that happen. Hence why you can write a C program that can be compiled for Linux, Windows and Mac with zero changes to the source code. However, C and C++ are still imperative languages in most other aspects because the thought process is still very much a "do this, now do this, now do this" algorithmic sequence of instructions.<br /><br /><span class="Apple-style-span" style="font-size: large;">Query Languages</span><br /><br />The hallmark of declarative languages thoughout history is probably SQL (referring strictly to set operations here). In SQL you describe the result set and let the DBMS decide the best way to produce that result set. For instance, consider this query:<br /><br /><pre class="brush: sql">select p.FirstName, p.LastName, a.AccountName<br />from Person p<br />inner join Account a<br />on p.PersonId = a.ResponsiblePerson<br />where a.IsActive = 1<br />order by p.FirstName, p.LastName<br /></pre><br />First we describe the columns that we want (this actually happens last, if you want to be technical). In the from clause we say what tables we want information from and specify how we want them matched up using the on clause of the join. In the where clause we specify what criteria for the rows that we want to show and in the order by we describe the sort order.<br /><br />All this was done strictly declaratively. If you have the opportunity to look at the execution plan, it all ends up being quite elaborate. It might consult two or three indexes before actually joining rows, selecting columns and ordering the result set not to mention all the asynchronous locking that took place so as not to run into race conditions. If we had to write this in C# or Java code it would be an extremely gnarly component and would probably be buggy and slow.<br /><br /><span class="Apple-style-span" style="font-size: large;">Expression Trees in C#</span><br /><br />Interestingly, .NET land is also developing into a declarative playground. The biggest step in this direction happened with Linq and it's expression trees. Now, the Linq query syntax is declarative, but I'm referring to something more basic. Expression trees can be broken down at run time by a processor that can analyze the contents of a lambda that it was passed. For instance, NHibernate can receive a method call like:<br /><br /><pre class="brush: csharp">var timsAccounts = accounts.Where(x =&gt; x.ResponsiblePerson == "Tim");<br /></pre><br />and pull out the meaning (ResponsiblePerson = Tim) and convert it into a SQL "where" clause at run time (sql = "where a.ResponsiblePerson = 'Tim'). The implications of this are wild, and in recent months and years have become very powerful. Examples include <a href="http://wiki.fluentnhibernate.org/Fluent_mapping">Fluent NHibernate</a>, <a href="http://code.google.com/p/moq/wiki/QuickStart">Moq</a>, and Castle Windsor's <a href="http://using.castleproject.org/display/IoC/Fluent+Registration+API">fluent registration API</a>. Both castle windsor and NHibernate both used to use XML configuration files but have since moved towards using expression trees in combination with dynamic proxies and interceptors to configure via code. This declarative approach is leading towards less code that has potential to be more efficient.<br /><br /><span class="Apple-style-span" style="font-size: large;">Treatise on Domain Specific Languages</span><br /><br />The topic of <a href="http://en.wikipedia.org/wiki/Domain-specific_language">domain specific languages</a> deserves an entire blog post. SQL and CSS are the obvious examples, but there are hundreds more. In one of my internships a coworker wrote a DSL to specify sort order for dictionaries for arcane natural languages and scripts. A simple DSL is much easier to develop than a GUI for the same purpose and can many times be easier for a non-techy user to learn and become productive in.<br /><br />The sad news is that colleges and universities are putting less focus on compiler &amp; parser classes. The assumption being that we have all the languages we need, why would we need more? The answer is simple: by providing a simple syntax to describe problems or solutions we can simplify the entire process of arriving to that solution. If the problem is abstracted away from the solution we can easily leverage constructs like multi-threading and highly optimized solutions. Sometime you should take a look at the byte codes that your compiler produces - ask yourself if you could have even thought of those sorts of mind bending tricks.<br /><br />We need domain specific languages because they simplify problems. They create more effective abstraction than even <a href="http://timkellogg.blogspot.com/2010/05/incidental-inversion-of-control.html">inversion of control</a> frameworks. Unfortunately, less people are learning about string processing these days. How many people have you worked with actually consider themselves proficient in regular expressions or compiler generators? (yet two more declarative DSLs that simplify solutions)<br /><br /><span class="Apple-style-span" style="font-size: large;">Conclusion</span><br /><br />Anytime you write code that is less imperative, it allows the layer underneath more room to innovate efficient algorithms. Surely this isn't surprising since any good programmer would feel exactly the same way towards a micro-managing supervisor. So after saying all this, it should be clear why I believe that the future of programming is declarative. Declarative syntaxes allow us to simplify the problem by simply stating what the problem is (or describing what the solution looks like) and allowing the underlying engine to determine the solution. As such, I believe we will be seeing the number of domain specific languages multiply in the years to come.</div>
